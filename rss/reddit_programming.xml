<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Fri, 09 Jan 2026 12:45:12 GMT</lastBuildDate>
    <item>
      <title>为什么 GPT-5.2 和 Opus 4.5 是编码的飞跃</title>
      <link>https://www.reddit.com/r/programming/comments/1q878q9/why_gpt52_and_opus_45_are_a_leap_forward_for/</link>
      <description><![CDATA[自从这些型号问世以来，炒作表盘似乎已经变成了 11...   由   提交 /u/scarey102   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q878q9/why_gpt52_and_opus_45_are_a_leap_forward_for/</guid>
      <pubDate>Fri, 09 Jan 2026 12:41:24 GMT</pubDate>
    </item>
    <item>
      <title>我们仍然像 20 世纪 80 年代一样进行调试</title>
      <link>https://www.reddit.com/r/programming/comments/1q86jo3/we_still_debug_like_its_the_1980s/</link>
      <description><![CDATA[ 由   提交/u/hirsimaki-markus  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q86jo3/we_still_debug_like_its_the_1980s/</guid>
      <pubDate>Fri, 09 Jan 2026 12:05:12 GMT</pubDate>
    </item>
    <item>
      <title>战争：安全需要更新，开发人员想要有效的构建</title>
      <link>https://www.reddit.com/r/programming/comments/1q8670x/war_security_wants_updates_devs_want_builds_that/</link>
      <description><![CDATA[安全团队通常专注于降低风险，这意味着告诉开发人员将依赖项升级到最新版本以避免 cve。另一方面，开发团队通常通过他们交付和保持稳定的程度来衡量，所以他们认为如果他们改变它就会破坏，所以他们遵循“如果没有破坏，就不要碰它”的方法。 这是团队的常见情况，还是只是一个有趣的模因？如果是真的，团队多久会遇到这种情况，现在是否有任何可用的解决方案，或者它仍然是一个需要修复的未解决问题？ 我创建一家软件供应链安全公司，我们的产品旨在从进攻的角度（而不仅仅是防御的角度）发现依赖项和整个软件供应链中的漏洞，我很想知道这是否是团队使用当前工具面临的真正的、持续的挑战，或者是否已经存在完善的解决方案。如果仍然存在差距，我们希望直接在我们的产品中解决它们。 此外，如果您有有趣的故事 - 最令人沮丧的依赖项升级是什么。你曾经不得不处理过吗？ （Java、npm、Python、OpenSSL…分享你的故事，让我们了解痛苦！）     提交href=&quot;https://www.reddit.com/user/StrikingExperience25&quot;&gt;/u/StrikingExperience25  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q8670x/war_security_wants_updates_devs_want_builds_that/</guid>
      <pubDate>Fri, 09 Jan 2026 11:46:57 GMT</pubDate>
    </item>
    <item>
      <title>为什么移动应用程序不征求分析数据收集的同意？</title>
      <link>https://www.reddit.com/r/programming/comments/1q84vpz/why_are_mobile_apps_not_asking_for_consent_for/</link>
      <description><![CDATA[这项研究有些陈旧，但比以往任何时候都更相关，因为应用程序商店中每天发布的应用程序数量惊人。 研究表明，该应用程序严重缺乏对数据隐私法规的遵守，这意味着很大一部分移动应用程序未能获得有效的用户同意来按照 GDPR 等法律的要求收集分析数据。虽然 GDPR 是针对欧盟的，但许多国家（巴西、印度、澳大利亚、韩国、英国等）和美国的许多州正在隐私监管竞赛中迎头赶上。 我们习惯于在网站上看到（是的，烦人的）cookie 同意问题。大多数移动应用程序也会收集分析数据，但我几乎没有看到任何移动应用程序要求用户同意收集分析数据。 即使使用隐私友好的解决方案，许多法规也规定，如果应用程序的功能不需要收集的数据，则需要征求用户的同意。许多人以“合法利益”为借口躲藏起来。但它有点难以防御，因为应用程序的运行不一定需要分析。不要因此责怪我，这就是法规的实际规定 - 无论我们认为它是否有意义。 但这并不意味着分析变得不重要。了解应用程序的使用方式确实很重要，这样我们才能改进应用程序。 这是我迄今为止的看法：  使用隐私优先的移动分析解决方案，该解决方案基本上会阻止个人身份信息 (PII) 的存储。 不要在分析中保存自定义字段，因为人为/开发人员错误可能会导致无意中存储 PII。存储的分析数据的形式应使其无法连接到个人 请求用户同意收集分析数据，即使在使用隐私优先的移动分析解决方案时也是如此。法规非常复杂，无论您的分析解决方案对隐私有多友好，其中一些法规仍然可能要求您征求用户同意。您发现一项法规可以免除您仅在进行用户分析时征求用户同意的义务，但这并不意味着您将遵守世界各地的所有隐私法规。  现在，您可以说... 等一下！如果我仍然会征求用户同意，我到底为什么要使用隐私优先的移动分析解决方案？ 因为：如果您将 PII 数据存储在分析中，您的责任就会呈指数级增长。首先，您与第三方公司共享 PII 数据。他们实际上用它做什么？所有提供完全免费或极其慷慨的免费套餐的平台；为什么这些解决方案实际上是免费的？它们对数据做了什么？此外，如果您将 PII 数据保存在分析中，您还需要开始承担数据删除请求的责任。如果有人要求您（假设您有移动应用程序）从系统中删除他/她的数据，您还需要清理分析数据。我想知道有多少开发者真正知道如何清理这些数据？ 征求用户同意。也许一半的用户会拒绝分析数据收集，但这没关系。在流量正常的情况下，应该仍然可以了解应用程序的使用方式。 使用隐私优先的移动分析解决方案，不要保存 PII 数据，这样当用户要求您从系统中删除他/她的数据时，您可以确保实际上没有任何可删除的内容（就分析数据而言）。但是，请跳过与第三方公司共享用户数据的责任。 隐私优先移动分析解决方案的缺点： - 忘记跟踪。特别是如果您正在投放广告，衡量广告的影响就变得更加困难。不幸的是，没有人能找到一个好的解决方案，这让包括我在内的许多人感到害怕。 - 您将无法获得一些长期趋势，即每月活跃的唯一用户数。如果一个解决方案声称他们首先是隐私，然后还告诉您可以获得每月活跃唯一用户等统计数据，那么您应该质疑它对隐私的友好程度。 值得一提的是，我不是律师，我在这里分享的所有内容都不是法律建议。这只是我的经验的收集和总结；我关心隐私，但我也发现这很难，而且在移动应用程序开发领域仍然令人难以置信地被忽视。 很高兴听到其他人对此主题的看法。   由   提交/u/cesncn   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q84vpz/why_are_mobile_apps_not_asking_for_consent_for/</guid>
      <pubDate>Fri, 09 Jan 2026 10:31:30 GMT</pubDate>
    </item>
    <item>
      <title>正确进行二分查找比您想象的要困难</title>
      <link>https://www.reddit.com/r/programming/comments/1q841bg/doing_binary_search_right_is_harder_than_you/</link>
      <description><![CDATA[ 由   提交/u/xarg  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q841bg/doing_binary_search_right_is_harder_than_you/</guid>
      <pubDate>Fri, 09 Jan 2026 09:39:23 GMT</pubDate>
    </item>
    <item>
      <title>我的 C++ 编译器刚刚写了自己的同人小说（编译时推理）</title>
      <link>https://www.reddit.com/r/programming/comments/1q831cb/my_c_compiler_just_wrote_its_own_fanfiction/</link>
      <description><![CDATA[不是真的，但至少它产生了自己的主角。 我一直痴迷于将语言模型推向它们不属于的地方。去年夏天，它是一个用 6502 程序集编写的 NES 的 1KB 二元模型。这周，我认为即使是 1983 年的硬件对我来说运行时间也太多了。 因此我构建了一个完全在 C++ 编译阶段运行的二元语言模型。  从技术上讲，它是通过 constexpr 和模板元编程实现的马尔可夫链。模型的权重被硬编码在数组中。一个有趣的部分是实现随机数生成器：由于编译器（大部分）是确定性的（理所当然），因此我使用 FNV-1a 算法对 __TIME__ 和 __DATE__ 进行哈希处理，以生成 constexpr Xorshift32 RNG。 当您运行二进制文件时，CPU 会执行零数学运算。它只是打印一个由编译器幻觉的字符串，每次编译时都不同。 ```cpp // 当你喝咖啡时，这一行完成所有工作 static constexpr NameGenerator&lt;15&gt;;结果（种子，T）；  int main() { // 只打印一个烘焙到数据段中的常量 std::cout &lt;&lt; [结果.名称](http://结果.名称) &lt;&lt; std::endl; }  ``` 除了它的乐趣之外，我希望它证明了一点：瓶颈并不总是我们的硬件。我们有回旋余地来重新定义何时应该执行，并将确定性推理直接烘焙到二进制文件中。 代码在这里： https://github.com/erodola/bigram-metacpp   由   提交/u/Brief_Argument8155  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q831cb/my_c_compiler_just_wrote_its_own_fanfiction/</guid>
      <pubDate>Fri, 09 Jan 2026 08:36:46 GMT</pubDate>
    </item>
    <item>
      <title>我的法学硕士编码工作流程将进入 2026 年，作者：Addy Osmani（Google）</title>
      <link>https://www.reddit.com/r/programming/comments/1q81trq/my_llm_coding_workflow_going_into_2026_by_addy/</link>
      <description><![CDATA[ 由   提交/u/RevillWeb  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q81trq/my_llm_coding_workflow_going_into_2026_by_addy/</guid>
      <pubDate>Fri, 09 Jan 2026 07:21:58 GMT</pubDate>
    </item>
    <item>
      <title>开放收据格式 (ORF)：开放的、与支付无关的数字收据标准</title>
      <link>https://www.reddit.com/r/programming/comments/1q7yvvw/open_receipt_format_orf_an_open_paymentagnostic/</link>
      <description><![CDATA[我一直致力于制定一个名为开放收据格式 (ORF) 的开放规范： https://openreceiptformat.github.io/orf-spec/ 以及支持该规范的生态系统（均为开源参考应用） https://openreceiptformat.github.io/Tommy-the-Tapir/ https://openreceiptformat.github.io/recipta/  这个想法很简单：收据是重要的记录，但今天它们被锁定在 POS 系统、支付提供商、电子邮件收件箱或专有应用程序中。 ORF 是： - 开放且供应商中立 - 明确不是支付标准 - 隐私至上（客户身份是可选的） - 设计为即使没有 POS API 也能工作 - 适用于实体和在线商务 它支持例如： - 草稿、确认和验证收据 - 人工确认（收银员/系统），而不仅仅是 API 信任 - QR / NFC / 基于链接的收据交付 - 用户设备上的本地优先收据存储 目标不是取代 POS 系统或支付 - 而是为人们提供可在个人财务工具、笔记中使用的便携式、结构化收据应用程序、审计或知识库。 规范很早，但可用，非常欢迎反馈： - 范围有意义吗？ - 缺少什么？ - 这在现实世界中会在哪里出现问题？ 很高兴回答问题或听到批评。   由   提交 /u/mikeatmnl   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q7yvvw/open_receipt_format_orf_an_open_paymentagnostic/</guid>
      <pubDate>Fri, 09 Jan 2026 04:43:05 GMT</pubDate>
    </item>
    <item>
      <title>缓存非确定性 LLM 响应的惊人复杂性</title>
      <link>https://www.reddit.com/r/programming/comments/1q7ykin/the_surprising_complexity_of_caching/</link>
      <description><![CDATA[我一直致力于在开发过程中降低 API 成本，但遇到了一个有趣的问题：如何缓存来自非确定性系统的响应？ 简单的方法不起作用： 您可能会认为：对请求进行哈希处理，缓存响应。但法学硕士的温度&gt; 0 对于相同的提示返回不同的响应。即使在 温度=0 下，某些模型也不是完全确定的。 对缓存键真正重要的是什么： 经过一些实验，我发现缓存需要考虑：  提示规范化至关重要 - 开发人员复制粘贴混乱。 “Hello\n” 与 “Hello” 与 “Hello” 应该命中相同的缓存。折叠空格和去除尾随空格将命中率提高了约 40%。 模型别名会破坏缓存 - gpt-4-turbo-latest 和 gpt-4-turbo-2024-04-09 可能指向同一模型，但它们的哈希值不同。您需要对它们进行标准化。 参数敏感性 - 温度对于缓存键很重要，但max_tokens则不然（它只是截断）。弄清楚哪些参数影响确定性，哪些参数只是输出格式是反复试验的结果。  流式传输问题： 流式响应是实时转发的（显然），但如何缓存它们？在流式传输开始之前，您不能等待完整的响应。目前的做法：立即转发，在后台重建并缓存。有效，但感觉很hacky。 我学到的东西：  JSON 的确定性哈希比看起来更难（关键排序很重要） LLM 的缓存失效很奇怪 - 响应不会“过期”在传统意义上 大多数收益来自开发迭代，而不是生产（相同提示的重复调试）  如果有人想查看实现细节，代码位于附加的链接中。 好奇其他人是否以不同的方式解决了这个问题。如何处理非确定性 API 的缓存？   由   提交/u/decentralizedbee  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q7ykin/the_surprising_complexity_of_caching/</guid>
      <pubDate>Fri, 09 Jan 2026 04:27:11 GMT</pubDate>
    </item>
    <item>
      <title>拉尔夫·威格姆实验：人工智能能否通过迭代循环进行有意义的自我改进？</title>
      <link>https://www.reddit.com/r/programming/comments/1q7x805/the_ralph_wiggum_experiment_can_ai_meaningfully/</link>
      <description><![CDATA[ 由   提交/u/utpalnadiger  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q7x805/the_ralph_wiggum_experiment_can_ai_meaningfully/</guid>
      <pubDate>Fri, 09 Jan 2026 03:23:54 GMT</pubDate>
    </item>
    <item>
      <title>从 DevX 到 BotX</title>
      <link>https://www.reddit.com/r/programming/comments/1q7uo2r/from_devx_to_botx/</link>
      <description><![CDATA[]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q7uo2r/from_devx_to_botx/</guid>
      <pubDate>Fri, 09 Jan 2026 01:30:47 GMT</pubDate>
    </item>
    <item>
      <title>如果 Stack Overflow 不是一个有毒的地狱，我们可能会更慢地放弃它</title>
      <link>https://www.reddit.com/r/programming/comments/1q7twjt/we_might_have_been_slower_to_abandon_stack/</link>
      <description><![CDATA[ 由   提交/u/R2_SWE2  [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q7twjt/we_might_have_been_slower_to_abandon_stack/</guid>
      <pubDate>Fri, 09 Jan 2026 00:57:59 GMT</pubDate>
    </item>
    <item>
      <title>我希望作为一名开发人员能够早点理解测试基础知识</title>
      <link>https://www.reddit.com/r/programming/comments/1q7ricq/testing_fundamentals_i_wish_i_understood_earlier/</link>
      <description><![CDATA[我注意到很多开发人员（包括过去的我）在理解为什么测试失败或要测试什么之前就跳入框架。 我写了一篇基础知识第一的文章，涵盖：  单元、集成与端到端 什么使测试有用 常见测试反模式 如何测试实际上有助于长期提高速度  博客链接：https://www.hexplain.space/blog/tt4bwNwfenmcQDT29U2e 什么测试概念对您来说迟来了？   由   提交/u/third_void  [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q7ricq/testing_fundamentals_i_wish_i_understood_earlier/</guid>
      <pubDate>Thu, 08 Jan 2026 23:18:32 GMT</pubDate>
    </item>
    <item>
      <title>1955 年的电脑教会了我什么</title>
      <link>https://www.reddit.com/r/programming/comments/1q7p5dw/what_a_1955_computer_taught_me/</link>
      <description><![CDATA[ 由   提交 /u/dreamnyt   [链接] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q7p5dw/what_a_1955_computer_taught_me/</guid>
      <pubDate>Thu, 08 Jan 2026 21:48:01 GMT</pubDate>
    </item>
    <item>
      <title>模板推导：隐藏的副本会扼杀你的表现（我的深入探讨的第二部分）</title>
      <link>https://www.reddit.com/r/programming/comments/1q7ly2o/template_deduction_the_hidden_copies_killing_your/</link>
      <description><![CDATA[ 由   提交 /u/the-_Ghost   [link] [评论]]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1q7ly2o/template_deduction_the_hidden_copies_killing_your/</guid>
      <pubDate>Thu, 08 Jan 2026 19:49:38 GMT</pubDate>
    </item>
    </channel>
</rss>